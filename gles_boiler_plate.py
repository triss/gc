header = """
////////////////////////////////////////////////////////////////////////////////
// some extra operators for our GA
//
// - all defined here instead of a header to allow dumping of code straight in
// to Processing, http://www.shadertoy.com, http://glsl.heroku.com etc.
////////////////////////////////////////////////////////////////////////////////

// basic operands for addition, subtraction,
// multiplication and division
float add(float a, float b) { return a + b; }
float sub(float a, float b) { return a - b; }
float div(float a, float b) { return a / b; }
float mul(float a, float b) { return a * b; }

// the following are operators that perform boolean operations
// > 0.5 is true < 0.5 is false

// converts a boolean to a float - 1. for True 0. for false
float btof(bool b) { return b ? 1. : 0.; }

// converts a float to a boolean
bool ftob(float f) { return fract(abs(f)) > 0.5; }

// not for floats
float fnot(float f) { return 1.0 - f; }

// less than and greater than
float lt(float a, float b) { return btof(a < b); }
float gt(float a, float b) { return btof(a > b); }

// if, then, else
float iff(float f, float then, float els) { return f > 0.5 ? then : els; }

// and, or, xor
float and(float a, float b) { return btof(ftob(a) && ftob(b)); }
float or (float a, float b) { return btof(ftob(a) || ftob(b)); }
float xor(float a, float b) { return btof(ftob(a) ^^ ftob(b)); }

// ors, ands, xors, less than and greater than's  that return one of
// there incoming values instead of just on or off
float anda(float a, float b) { return ftob(a) && ftob(b) ? a : 0.; }
float andb(float a, float b) { return ftob(a) && ftob(b) ? b : 0.; }
float ora (float a, float b) { return ftob(a) || ftob(b) ? a : 0.; }
float orb (float a, float b) { return ftob(a) || ftob(b) ? b : 0.; }
float xora(float a, float b) { return ftob(a) ^^ ftob(b) ? a : 0.; }
float xorb(float a, float b) { return ftob(a) ^^ ftob(b) ? b : 0.; }
float lta (float a, float b) { return a < b ? a : 0.; }
float ltb (float a, float b) { return a < b ? b : 0.; }
float gta (float a, float b) { return a > b ? a : 0.; }
float gtb (float a, float b) { return a > b ? b : 0.; }

// unipolar versions of bipolar functions
float unisin(float f) { return sin(f) * 0.5 + 0.5; }
float unicos(float f) { return cos(f) * 0.5 + 0.5; }
float unitan(float f) { return tan(f) * 0.5 + 0.5; }
float uniasin(float f) { return asin(f) * 0.5 + 0.5; }
float uniacos(float f) { return acos(f) * 0.5 + 0.5; }
float uniatan(float f) { return atan(f) * 0.5 + 0.5; }

////////////////////////////////////////////////////////////////////////////////
// the actual shader code starts here
////////////////////////////////////////////////////////////////////////////////

void main(void)
{
    // normalize x and y values
    vec2 uv = gl_FragCoord.xy / iResolution.xy;

    ////////////////////////////////////////////////////////////////////////////
    // code generated by GA
    ////////////////////////////////////////////////////////////////////////////
"""

footer = """

    // output our function
    gl_FragColor = vec4(v, v, v, 1.0);
}
"""
